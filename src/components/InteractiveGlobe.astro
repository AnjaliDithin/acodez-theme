---
// InteractiveGlobe.astro
interface Props {
  innerColor?: string;
  outerColor1?: string;
  outerColor2?: string;
}

const { 
  innerColor = '#0E1216',
  outerColor1 = '#00CCE6', // Cyan
  outerColor2 = '#8000CC'  // Purple
} = Astro.props;
---

<div class="globe-container">
  <canvas id="globe-canvas"></canvas>
</div>


<script>
  import * as THREE from 'three';

  // Get color props from data attributes
  const container = document.querySelector('.globe-container') as HTMLElement;
  const canvas = document.getElementById('globe-canvas') as HTMLCanvasElement;

  if (container && canvas) {
    const innerColor = container.dataset.innerColor || '#0E1216';
    const outerColor1 = container.dataset.outerColor1 || '#00CCE6';
    const outerColor2 = container.dataset.outerColor2 || '#8000CC';

    // Helper function to convert hex to RGB
    function hexToRgb(hex: string) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16) / 255,
        g: parseInt(result[2], 16) / 255,
        b: parseInt(result[3], 16) / 255
      } : { r: 0, g: 0, b: 0 };
    }

    // Scene setup
    const scene = new THREE.Scene();

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 250;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      canvas: canvas,
      antialias: true, 
      alpha: true 
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x000000, 0); // Fully transparent background

    // Create particle grid on sphere
    const particleCount = 20000;
    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const originalPositions = new Float32Array(particleCount * 3);

    const radius = 80;
    
    // Convert color props to RGB
    const innerColorRgb = hexToRgb(innerColor);
    const outerColor1Rgb = hexToRgb(outerColor1);
    const outerColor2Rgb = hexToRgb(outerColor2);
    
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      
      // Fibonacci sphere distribution for even coverage
      const phi = Math.acos(-1 + (2 * i) / particleCount);
      const theta = Math.sqrt(particleCount * Math.PI) * phi;
      
      const x = radius * Math.cos(theta) * Math.sin(phi);
      const y = radius * Math.sin(theta) * Math.sin(phi);
      const z = radius * Math.cos(phi);
      
      positions[i3] = x;
      positions[i3 + 1] = y;
      positions[i3 + 2] = z;
      
      originalPositions[i3] = x;
      originalPositions[i3 + 1] = y;
      originalPositions[i3 + 2] = z;
      
      // Color gradient based on distance from center (radial)
      const distanceFromCenter = Math.sqrt(x * x + y * y + z * z);
      const normalizedDistance = distanceFromCenter / radius;
      
      // Mix between two outer colors based on position
      const angle = Math.atan2(y, x);
      const mixFactor = (Math.sin(angle * 2) + 1) / 2;
      
      colors[i3] = innerColorRgb.r + (normalizedDistance * (outerColor1Rgb.r * (1 - mixFactor) + outerColor2Rgb.r * mixFactor));
      colors[i3 + 1] = innerColorRgb.g + (normalizedDistance * (outerColor1Rgb.g * (1 - mixFactor) + outerColor2Rgb.g * mixFactor));
      colors[i3 + 2] = innerColorRgb.b + (normalizedDistance * (outerColor1Rgb.b * (1 - mixFactor) + outerColor2Rgb.b * mixFactor));
      
      sizes[i] = Math.random() * 1.5 + 0.8;
    }

    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Store original positions for wave calculation
    particles.userData = { originalPositions };

    // Particle material with glow
    const particleMaterial = new THREE.PointsMaterial({
      size: 1.8,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      sizeAttenuation: true,
      depthWrite: false
    });

    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);

    // Mouse tracking
    const mouse = { x: 0, y: 0 };

    const handleMouseMove = (event: MouseEvent) => {
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    };

    container.addEventListener('mousemove', handleMouseMove);

    // Animation loop
    let time = 0;
    const animate = () => {
      requestAnimationFrame(animate);
      time += 0.008;

      const positions = particleSystem.geometry.attributes.position.array as Float32Array;
      const original = particleSystem.geometry.userData.originalPositions as Float32Array;
      
      // Create complex wave patterns
      for (let i = 0; i < positions.length; i += 3) {
        const x = original[i];
        const y = original[i + 1];
        const z = original[i + 2];
        
        // Multiple wave frequencies for complex distortion
        const angle1 = Math.atan2(y, x);
        const angle2 = Math.atan2(z, Math.sqrt(x * x + y * y));
        
        const wave1 = Math.sin(angle1 * 4 + time * 2) * 8;
        const wave2 = Math.cos(angle2 * 6 - time * 1.5) * 6;
        const wave3 = Math.sin(angle1 * 8 + angle2 * 4 + time * 3) * 4;
        
        const distance = Math.sqrt(x * x + y * y + z * z);
        const displacement = wave1 + wave2 + wave3;
        const factor = (distance + displacement) / distance;
        
        positions[i] = x * factor;
        positions[i + 1] = y * factor;
        positions[i + 2] = z * factor;
      }
      
      particleSystem.geometry.attributes.position.needsUpdate = true;
      
      // Subtle rotation based on mouse
      particleSystem.rotation.y += (mouse.x * 0.3 - particleSystem.rotation.y) * 0.02;
      particleSystem.rotation.x += (mouse.y * 0.3 - particleSystem.rotation.x) * 0.02;
      
      // Continuous slow rotation
      particleSystem.rotation.y += 0.002;

      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    const handleResize = () => {
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);
  }
</script>

<script is:inline define:vars={{ innerColor, outerColor1, outerColor2 }}>
  // Pass props via data attributes
  const container = document.querySelector('.globe-container');
  if (container) {
    container.dataset.innerColor = innerColor;
    container.dataset.outerColor1 = outerColor1;
    container.dataset.outerColor2 = outerColor2;
  }
</script>